{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.type = type;\nexports.specialCharMap = void 0;\nvar _dom = require(\"@testing-library/dom\");\nvar _utils = require(\"./utils\");\nvar _click = require(\"./click\");\nvar _navigationKey = require(\"./keys/navigation-key\");\n\n// TODO: wrap in asyncWrapper\nconst modifierCallbackMap = {\n  ...createModifierCallbackEntries({\n    name: 'shift',\n    key: 'Shift',\n    keyCode: 16,\n    modifierProperty: 'shiftKey'\n  }),\n  ...createModifierCallbackEntries({\n    name: 'ctrl',\n    key: 'Control',\n    keyCode: 17,\n    modifierProperty: 'ctrlKey'\n  }),\n  ...createModifierCallbackEntries({\n    name: 'alt',\n    key: 'Alt',\n    keyCode: 18,\n    modifierProperty: 'altKey'\n  }),\n  ...createModifierCallbackEntries({\n    name: 'meta',\n    key: 'Meta',\n    keyCode: 93,\n    modifierProperty: 'metaKey'\n  }),\n  // capslock is inline because of the need to fire both keydown and keyup on use, while preserving the modifier state.\n  '{capslock}': function capslockOn(_ref) {\n    let {\n      currentElement,\n      eventOverrides\n    } = _ref;\n    const newEventOverrides = {\n      modifierCapsLock: true\n    };\n    _dom.fireEvent.keyDown(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n    _dom.fireEvent.keyUp(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n    return {\n      eventOverrides: newEventOverrides\n    };\n  },\n  '{/capslock}': function capslockOff(_ref2) {\n    let {\n      currentElement,\n      eventOverrides\n    } = _ref2;\n    const newEventOverrides = {\n      modifierCapsLock: false\n    };\n    _dom.fireEvent.keyDown(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n    _dom.fireEvent.keyUp(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n    return {\n      eventOverrides: newEventOverrides\n    };\n  }\n};\nconst specialCharMap = {\n  arrowLeft: '{arrowleft}',\n  arrowRight: '{arrowright}',\n  arrowDown: '{arrowdown}',\n  arrowUp: '{arrowup}',\n  enter: '{enter}',\n  escape: '{esc}',\n  delete: '{del}',\n  backspace: '{backspace}',\n  home: '{home}',\n  end: '{end}',\n  selectAll: '{selectall}',\n  space: '{space}',\n  whitespace: ' '\n};\nexports.specialCharMap = specialCharMap;\nconst specialCharCallbackMap = {\n  [specialCharMap.arrowLeft]: (0, _navigationKey.navigationKey)('ArrowLeft'),\n  [specialCharMap.arrowRight]: (0, _navigationKey.navigationKey)('ArrowRight'),\n  [specialCharMap.arrowDown]: handleArrowDown,\n  [specialCharMap.arrowUp]: handleArrowUp,\n  [specialCharMap.home]: (0, _navigationKey.navigationKey)('Home'),\n  [specialCharMap.end]: (0, _navigationKey.navigationKey)('End'),\n  [specialCharMap.enter]: handleEnter,\n  [specialCharMap.escape]: handleEsc,\n  [specialCharMap.delete]: handleDel,\n  [specialCharMap.backspace]: handleBackspace,\n  [specialCharMap.selectAll]: handleSelectall,\n  [specialCharMap.space]: handleSpace,\n  [specialCharMap.whitespace]: handleSpace\n};\nfunction wait(time) {\n  return new Promise(resolve => setTimeout(() => resolve(), time));\n} // this needs to be wrapped in the event/asyncWrapper for React's act and angular's change detection\n// depending on whether it will be async.\n\nasync function type(element, text) {\n  let {\n    delay = 0,\n    ...options\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // we do not want to wrap in the asyncWrapper if we're not\n  // going to actually be doing anything async, so we only wrap\n  // if the delay is greater than 0\n  let result;\n  if (delay > 0) {\n    await (0, _dom.getConfig)().asyncWrapper(async () => {\n      result = await typeImpl(element, text, {\n        delay,\n        ...options\n      });\n    });\n  } else {\n    result = typeImpl(element, text, {\n      delay,\n      ...options\n    });\n  }\n  return result;\n}\nasync function typeImpl(element, text, _ref3) {\n  let {\n    delay,\n    skipClick = false,\n    skipAutoClose = false,\n    initialSelectionStart,\n    initialSelectionEnd\n  } = _ref3;\n  if (element.disabled) return;\n  if (!skipClick) (0, _click.click)(element);\n  if ((0, _utils.isContentEditable)(element) && document.getSelection().rangeCount === 0) {\n    const range = document.createRange();\n    range.setStart(element, 0);\n    range.setEnd(element, 0);\n    document.getSelection().addRange(range);\n  } // The focused element could change between each event, so get the currently active element each time\n\n  const currentElement = () => (0, _utils.getActiveElement)(element.ownerDocument); // by default, a new element has it's selection start and end at 0\n  // but most of the time when people call \"type\", they expect it to type\n  // at the end of the current input value. So, if the selection start\n  // and end are both the default of 0, then we'll go ahead and change\n  // them to the length of the current value.\n  // the only time it would make sense to pass the initialSelectionStart or\n  // initialSelectionEnd is if you have an input with a value and want to\n  // explicitely start typing with the cursor at 0. Not super common.\n\n  const value = (0, _utils.getValue)(currentElement());\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n  if (value != null && selectionStart === 0 && selectionEnd === 0) {\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), initialSelectionStart != null ? initialSelectionStart : value.length, initialSelectionEnd != null ? initialSelectionEnd : value.length);\n  }\n  const eventCallbacks = queueCallbacks();\n  await runCallbacks(eventCallbacks);\n  function queueCallbacks() {\n    const callbacks = [];\n    let remainingString = text;\n    while (remainingString) {\n      const {\n        callback,\n        remainingString: newRemainingString\n      } = getNextCallback(remainingString, skipAutoClose);\n      callbacks.push(callback);\n      remainingString = newRemainingString;\n    }\n    return callbacks;\n  }\n  async function runCallbacks(callbacks) {\n    const eventOverrides = {};\n    let prevWasMinus, prevWasPeriod, prevValue, typedValue;\n    for (const callback of callbacks) {\n      if (delay > 0) await wait(delay);\n      if (!currentElement().disabled) {\n        const returnValue = callback({\n          currentElement,\n          prevWasMinus,\n          prevWasPeriod,\n          prevValue,\n          eventOverrides,\n          typedValue\n        });\n        Object.assign(eventOverrides, returnValue == null ? void 0 : returnValue.eventOverrides);\n        prevWasMinus = returnValue == null ? void 0 : returnValue.prevWasMinus;\n        prevWasPeriod = returnValue == null ? void 0 : returnValue.prevWasPeriod;\n        prevValue = returnValue == null ? void 0 : returnValue.prevValue;\n        typedValue = returnValue == null ? void 0 : returnValue.typedValue;\n      }\n    }\n  }\n}\nfunction getNextCallback(remainingString, skipAutoClose) {\n  const modifierCallback = getModifierCallback(remainingString, skipAutoClose);\n  if (modifierCallback) {\n    return modifierCallback;\n  }\n  const specialCharCallback = getSpecialCharCallback(remainingString);\n  if (specialCharCallback) {\n    return specialCharCallback;\n  }\n  return getTypeCallback(remainingString);\n}\nfunction getModifierCallback(remainingString, skipAutoClose) {\n  const modifierKey = Object.keys(modifierCallbackMap).find(key => remainingString.startsWith(key));\n  if (!modifierKey) {\n    return null;\n  }\n  const callback = modifierCallbackMap[modifierKey]; // if this modifier has an associated \"close\" callback and the developer\n  // doesn't close it themselves, then we close it for them automatically\n  // Effectively if they send in: '{alt}a' then we type: '{alt}a{/alt}'\n\n  if (!skipAutoClose && callback.closeName && !remainingString.includes(callback.closeName)) {\n    remainingString += callback.closeName;\n  }\n  remainingString = remainingString.slice(modifierKey.length);\n  return {\n    callback,\n    remainingString\n  };\n}\nfunction getSpecialCharCallback(remainingString) {\n  const specialChar = Object.keys(specialCharCallbackMap).find(key => remainingString.startsWith(key));\n  if (!specialChar) {\n    return null;\n  }\n  return {\n    callback: specialCharCallbackMap[specialChar],\n    remainingString: remainingString.slice(specialChar.length)\n  };\n}\nfunction getTypeCallback(remainingString) {\n  const character = remainingString[0];\n  const callback = context => typeCharacter(character, context);\n  return {\n    callback,\n    remainingString: remainingString.slice(1)\n  };\n}\nfunction setSelectionRange(_ref4) {\n  let {\n    currentElement,\n    newValue,\n    newSelectionStart\n  } = _ref4;\n  // if we *can* change the selection start, then we will if the new value\n  // is the same as the current value (so it wasn't programatically changed\n  // when the fireEvent.input was triggered).\n  // The reason we have to do this at all is because it actually *is*\n  // programmatically changed by fireEvent.input, so we have to simulate the\n  // browser's default behavior\n  const value = (0, _utils.getValue)(currentElement());\n  if (value === newValue) {\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), newSelectionStart, newSelectionStart);\n  } else {\n    // If the currentValue is different than the expected newValue and we *can*\n    // change the selection range, than we should set it to the length of the\n    // currentValue to ensure that the browser behavior is mimicked.\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), value.length, value.length);\n  }\n}\nfunction fireInputEventIfNeeded(_ref5) {\n  let {\n    currentElement,\n    newValue,\n    newSelectionStart,\n    eventOverrides\n  } = _ref5;\n  const prevValue = (0, _utils.getValue)(currentElement());\n  if (!currentElement().readOnly && !(0, _utils.isClickableInput)(currentElement()) && newValue !== prevValue) {\n    if ((0, _utils.isContentEditable)(currentElement())) {\n      _dom.fireEvent.input(currentElement(), {\n        target: {\n          textContent: newValue\n        },\n        ...eventOverrides\n      });\n    } else {\n      _dom.fireEvent.input(currentElement(), {\n        target: {\n          value: newValue\n        },\n        ...eventOverrides\n      });\n    }\n    setSelectionRange({\n      currentElement,\n      newValue,\n      newSelectionStart\n    });\n  }\n  return {\n    prevValue\n  };\n}\nfunction typeCharacter(char, _ref6) {\n  let {\n    currentElement,\n    prevWasMinus = false,\n    prevWasPeriod = false,\n    prevValue = '',\n    typedValue = '',\n    eventOverrides\n  } = _ref6;\n  const key = char; // TODO: check if this also valid for characters with diacritic markers e.g. úé etc\n\n  const keyCode = char.charCodeAt(0);\n  let nextPrevWasMinus, nextPrevWasPeriod;\n  const textToBeTyped = typedValue + char;\n  const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n  if (keyDownDefaultNotPrevented) {\n    const keyPressDefaultNotPrevented = _dom.fireEvent.keyPress(currentElement(), {\n      key,\n      keyCode,\n      charCode: keyCode,\n      ...eventOverrides\n    });\n    if ((0, _utils.getValue)(currentElement()) != null && keyPressDefaultNotPrevented) {\n      let newEntry = char;\n      if (prevWasMinus) {\n        newEntry = `-${char}`;\n      } else if (prevWasPeriod) {\n        newEntry = `${prevValue}.${char}`;\n      }\n      if ((0, _utils.isValidDateValue)(currentElement(), textToBeTyped)) {\n        newEntry = textToBeTyped;\n      }\n      const timeNewEntry = (0, _utils.buildTimeValue)(textToBeTyped);\n      if ((0, _utils.isValidInputTimeValue)(currentElement(), timeNewEntry)) {\n        newEntry = timeNewEntry;\n      }\n      const inputEvent = fireInputEventIfNeeded({\n        ...(0, _utils.calculateNewValue)(newEntry, currentElement()),\n        eventOverrides: {\n          data: key,\n          inputType: 'insertText',\n          ...eventOverrides\n        },\n        currentElement\n      });\n      prevValue = inputEvent.prevValue;\n      if ((0, _utils.isValidDateValue)(currentElement(), textToBeTyped)) {\n        _dom.fireEvent.change(currentElement(), {\n          target: {\n            value: textToBeTyped\n          }\n        });\n      }\n      fireChangeForInputTimeIfValid(currentElement, prevValue, timeNewEntry); // typing \"-\" into a number input will not actually update the value\n      // so for the next character we type, the value should be set to\n      // `-${newEntry}`\n      // we also preserve the prevWasMinus when the value is unchanged due\n      // to typing an invalid character (typing \"-a3\" results in \"-3\")\n      // same applies for the decimal character.\n\n      if (currentElement().type === 'number') {\n        const newValue = (0, _utils.getValue)(currentElement());\n        if (newValue === prevValue && newEntry !== '-') {\n          nextPrevWasMinus = prevWasMinus;\n        } else {\n          nextPrevWasMinus = newEntry === '-';\n        }\n        if (newValue === prevValue && newEntry !== '.') {\n          nextPrevWasPeriod = prevWasPeriod;\n        } else {\n          nextPrevWasPeriod = newEntry === '.';\n        }\n      }\n    }\n  }\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n  return {\n    prevWasMinus: nextPrevWasMinus,\n    prevWasPeriod: nextPrevWasPeriod,\n    prevValue,\n    typedValue: textToBeTyped\n  };\n}\nfunction fireChangeForInputTimeIfValid(currentElement, prevValue, timeNewEntry) {\n  if ((0, _utils.isValidInputTimeValue)(currentElement(), timeNewEntry) && prevValue !== timeNewEntry) {\n    _dom.fireEvent.change(currentElement(), {\n      target: {\n        value: timeNewEntry\n      }\n    });\n  }\n} // yes, calculateNewBackspaceValue and calculateNewValue look extremely similar\n// and you may be tempted to create a shared abstraction.\n// If you, brave soul, decide to so endevor, please increment this count\n// when you inevitably fail: 1\n\nfunction calculateNewBackspaceValue(element) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n  const value = (0, _utils.getValue)(element);\n  let newValue, newSelectionStart;\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value.slice(0, value.length - 1);\n    newSelectionStart = selectionStart - 1;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = value;\n      newSelectionStart = selectionStart;\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value.slice(0, value.length - 1);\n      newSelectionStart = selectionStart - 1;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart - 1) + value.slice(selectionEnd);\n      newSelectionStart = selectionStart - 1;\n    }\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart);\n    newValue = firstPart + value.slice(selectionEnd);\n    newSelectionStart = firstPart.length;\n  }\n  return {\n    newValue,\n    newSelectionStart\n  };\n}\nfunction calculateNewDeleteValue(element) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n  const value = (0, _utils.getValue)(element);\n  let newValue;\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = value.slice(1);\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart) + value.slice(selectionEnd + 1);\n    }\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart);\n    newValue = firstPart + value.slice(selectionEnd);\n  }\n  return {\n    newValue,\n    newSelectionStart: selectionStart\n  };\n}\nfunction createModifierCallbackEntries(_ref7) {\n  let {\n    name,\n    key,\n    keyCode,\n    modifierProperty\n  } = _ref7;\n  const openName = `{${name}}`;\n  const closeName = `{/${name}}`;\n  function open(_ref8) {\n    let {\n      currentElement,\n      eventOverrides\n    } = _ref8;\n    const newEventOverrides = {\n      [modifierProperty]: true\n    };\n    _dom.fireEvent.keyDown(currentElement(), {\n      key,\n      keyCode,\n      which: keyCode,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n    return {\n      eventOverrides: newEventOverrides\n    };\n  }\n  open.closeName = closeName;\n  function close(_ref9) {\n    let {\n      currentElement,\n      eventOverrides\n    } = _ref9;\n    const newEventOverrides = {\n      [modifierProperty]: false\n    };\n    _dom.fireEvent.keyUp(currentElement(), {\n      key,\n      keyCode,\n      which: keyCode,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n    return {\n      eventOverrides: newEventOverrides\n    };\n  }\n  return {\n    [openName]: open,\n    [closeName]: close\n  };\n}\nfunction handleEnter(_ref10) {\n  let {\n    currentElement,\n    eventOverrides\n  } = _ref10;\n  const key = 'Enter';\n  const keyCode = 13;\n  const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n  if (keyDownDefaultNotPrevented) {\n    const keyPressDefaultNotPrevented = _dom.fireEvent.keyPress(currentElement(), {\n      key,\n      keyCode,\n      charCode: keyCode,\n      ...eventOverrides\n    });\n    if (keyPressDefaultNotPrevented) {\n      if ((0, _utils.isClickableInput)(currentElement()) ||\n      // Links with href defined should handle Enter the same as a click\n      (0, _utils.isInstanceOfElement)(currentElement(), 'HTMLAnchorElement') && currentElement().href) {\n        _dom.fireEvent.click(currentElement(), {\n          ...eventOverrides\n        });\n      }\n      if (currentElement().tagName === 'TEXTAREA') {\n        const {\n          newValue,\n          newSelectionStart\n        } = (0, _utils.calculateNewValue)('\\n', currentElement());\n        _dom.fireEvent.input(currentElement(), {\n          target: {\n            value: newValue\n          },\n          inputType: 'insertLineBreak',\n          ...eventOverrides\n        });\n        setSelectionRange({\n          currentElement,\n          newValue,\n          newSelectionStart\n        });\n      }\n      if (currentElement().tagName === 'INPUT' && currentElement().form && (currentElement().form.querySelectorAll('input').length === 1 || currentElement().form.querySelector('input[type=\"submit\"]') || currentElement().form.querySelector('button[type=\"submit\"]'))) {\n        _dom.fireEvent.submit(currentElement().form);\n      }\n    }\n  }\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\nfunction handleEsc(_ref11) {\n  let {\n    currentElement,\n    eventOverrides\n  } = _ref11;\n  const key = 'Escape';\n  const keyCode = 27;\n  _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  }); // NOTE: Browsers do not fire a keypress on meta key presses\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\nfunction handleDel(_ref12) {\n  let {\n    currentElement,\n    eventOverrides\n  } = _ref12;\n  const key = 'Delete';\n  const keyCode = 46;\n  const keyPressDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n  if (keyPressDefaultNotPrevented) {\n    fireInputEventIfNeeded({\n      ...calculateNewDeleteValue(currentElement()),\n      eventOverrides: {\n        inputType: 'deleteContentForward',\n        ...eventOverrides\n      },\n      currentElement\n    });\n  }\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\nfunction handleBackspace(_ref13) {\n  let {\n    currentElement,\n    eventOverrides\n  } = _ref13;\n  const key = 'Backspace';\n  const keyCode = 8;\n  const keyPressDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n  if (keyPressDefaultNotPrevented) {\n    fireInputEventIfNeeded({\n      ...calculateNewBackspaceValue(currentElement()),\n      eventOverrides: {\n        inputType: 'deleteContentBackward',\n        ...eventOverrides\n      },\n      currentElement\n    });\n  }\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\nfunction handleSelectall(_ref14) {\n  let {\n    currentElement\n  } = _ref14;\n  currentElement().setSelectionRange(0, (0, _utils.getValue)(currentElement()).length);\n}\nfunction handleSpace(context) {\n  if ((0, _utils.isClickableInput)(context.currentElement())) {\n    handleSpaceOnClickable(context);\n    return;\n  }\n  typeCharacter(' ', context);\n}\nfunction handleSpaceOnClickable(_ref15) {\n  let {\n    currentElement,\n    eventOverrides\n  } = _ref15;\n  const key = ' ';\n  const keyCode = 32;\n  const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n  if (keyDownDefaultNotPrevented) {\n    _dom.fireEvent.keyPress(currentElement(), {\n      key,\n      keyCode,\n      charCode: keyCode,\n      ...eventOverrides\n    });\n  }\n  const keyUpDefaultNotPrevented = _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n  if (keyDownDefaultNotPrevented && keyUpDefaultNotPrevented) {\n    _dom.fireEvent.click(currentElement(), {\n      ...eventOverrides\n    });\n  }\n}\nfunction handleArrowDown(_ref16) {\n  let {\n    currentElement,\n    eventOverrides\n  } = _ref16;\n  const key = 'ArrowDown';\n  const keyCode = 40;\n  _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\nfunction handleArrowUp(_ref17) {\n  let {\n    currentElement,\n    eventOverrides\n  } = _ref17;\n  const key = 'ArrowUp';\n  const keyCode = 38;\n  _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","type","specialCharMap","_dom","require","_utils","_click","_navigationKey","modifierCallbackMap","createModifierCallbackEntries","name","key","keyCode","modifierProperty","capslockOn","_ref","currentElement","eventOverrides","newEventOverrides","modifierCapsLock","fireEvent","keyDown","which","keyUp","capslockOff","_ref2","arrowLeft","arrowRight","arrowDown","arrowUp","enter","escape","delete","backspace","home","end","selectAll","space","whitespace","specialCharCallbackMap","navigationKey","handleArrowDown","handleArrowUp","handleEnter","handleEsc","handleDel","handleBackspace","handleSelectall","handleSpace","wait","time","Promise","resolve","setTimeout","element","text","delay","options","arguments","length","undefined","result","getConfig","asyncWrapper","typeImpl","_ref3","skipClick","skipAutoClose","initialSelectionStart","initialSelectionEnd","disabled","click","isContentEditable","document","getSelection","rangeCount","range","createRange","setStart","setEnd","addRange","getActiveElement","ownerDocument","getValue","selectionStart","selectionEnd","getSelectionRange","setSelectionRangeIfNecessary","eventCallbacks","queueCallbacks","runCallbacks","callbacks","remainingString","callback","newRemainingString","getNextCallback","push","prevWasMinus","prevWasPeriod","prevValue","typedValue","returnValue","assign","modifierCallback","getModifierCallback","specialCharCallback","getSpecialCharCallback","getTypeCallback","modifierKey","keys","find","startsWith","closeName","includes","slice","specialChar","character","context","typeCharacter","setSelectionRange","_ref4","newValue","newSelectionStart","fireInputEventIfNeeded","_ref5","readOnly","isClickableInput","input","target","textContent","char","_ref6","charCodeAt","nextPrevWasMinus","nextPrevWasPeriod","textToBeTyped","keyDownDefaultNotPrevented","keyPressDefaultNotPrevented","keyPress","charCode","newEntry","isValidDateValue","timeNewEntry","buildTimeValue","isValidInputTimeValue","inputEvent","calculateNewValue","data","inputType","change","fireChangeForInputTimeIfValid","calculateNewBackspaceValue","firstPart","calculateNewDeleteValue","_ref7","openName","open","_ref8","close","_ref9","_ref10","isInstanceOfElement","href","tagName","form","querySelectorAll","querySelector","submit","_ref11","_ref12","_ref13","_ref14","handleSpaceOnClickable","_ref15","keyUpDefaultNotPrevented","_ref16","_ref17"],"sources":["C:/Users/1000071428/Downloads/01-starting-project (2)/01-starting-project/node_modules/@testing-library/user-event/dist/type.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.type = type;\nexports.specialCharMap = void 0;\n\nvar _dom = require(\"@testing-library/dom\");\n\nvar _utils = require(\"./utils\");\n\nvar _click = require(\"./click\");\n\nvar _navigationKey = require(\"./keys/navigation-key\");\n\n// TODO: wrap in asyncWrapper\nconst modifierCallbackMap = { ...createModifierCallbackEntries({\n    name: 'shift',\n    key: 'Shift',\n    keyCode: 16,\n    modifierProperty: 'shiftKey'\n  }),\n  ...createModifierCallbackEntries({\n    name: 'ctrl',\n    key: 'Control',\n    keyCode: 17,\n    modifierProperty: 'ctrlKey'\n  }),\n  ...createModifierCallbackEntries({\n    name: 'alt',\n    key: 'Alt',\n    keyCode: 18,\n    modifierProperty: 'altKey'\n  }),\n  ...createModifierCallbackEntries({\n    name: 'meta',\n    key: 'Meta',\n    keyCode: 93,\n    modifierProperty: 'metaKey'\n  }),\n  // capslock is inline because of the need to fire both keydown and keyup on use, while preserving the modifier state.\n  '{capslock}': function capslockOn({\n    currentElement,\n    eventOverrides\n  }) {\n    const newEventOverrides = {\n      modifierCapsLock: true\n    };\n\n    _dom.fireEvent.keyDown(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    _dom.fireEvent.keyUp(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    return {\n      eventOverrides: newEventOverrides\n    };\n  },\n  '{/capslock}': function capslockOff({\n    currentElement,\n    eventOverrides\n  }) {\n    const newEventOverrides = {\n      modifierCapsLock: false\n    };\n\n    _dom.fireEvent.keyDown(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    _dom.fireEvent.keyUp(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    return {\n      eventOverrides: newEventOverrides\n    };\n  }\n};\nconst specialCharMap = {\n  arrowLeft: '{arrowleft}',\n  arrowRight: '{arrowright}',\n  arrowDown: '{arrowdown}',\n  arrowUp: '{arrowup}',\n  enter: '{enter}',\n  escape: '{esc}',\n  delete: '{del}',\n  backspace: '{backspace}',\n  home: '{home}',\n  end: '{end}',\n  selectAll: '{selectall}',\n  space: '{space}',\n  whitespace: ' '\n};\nexports.specialCharMap = specialCharMap;\nconst specialCharCallbackMap = {\n  [specialCharMap.arrowLeft]: (0, _navigationKey.navigationKey)('ArrowLeft'),\n  [specialCharMap.arrowRight]: (0, _navigationKey.navigationKey)('ArrowRight'),\n  [specialCharMap.arrowDown]: handleArrowDown,\n  [specialCharMap.arrowUp]: handleArrowUp,\n  [specialCharMap.home]: (0, _navigationKey.navigationKey)('Home'),\n  [specialCharMap.end]: (0, _navigationKey.navigationKey)('End'),\n  [specialCharMap.enter]: handleEnter,\n  [specialCharMap.escape]: handleEsc,\n  [specialCharMap.delete]: handleDel,\n  [specialCharMap.backspace]: handleBackspace,\n  [specialCharMap.selectAll]: handleSelectall,\n  [specialCharMap.space]: handleSpace,\n  [specialCharMap.whitespace]: handleSpace\n};\n\nfunction wait(time) {\n  return new Promise(resolve => setTimeout(() => resolve(), time));\n} // this needs to be wrapped in the event/asyncWrapper for React's act and angular's change detection\n// depending on whether it will be async.\n\n\nasync function type(element, text, {\n  delay = 0,\n  ...options\n} = {}) {\n  // we do not want to wrap in the asyncWrapper if we're not\n  // going to actually be doing anything async, so we only wrap\n  // if the delay is greater than 0\n  let result;\n\n  if (delay > 0) {\n    await (0, _dom.getConfig)().asyncWrapper(async () => {\n      result = await typeImpl(element, text, {\n        delay,\n        ...options\n      });\n    });\n  } else {\n    result = typeImpl(element, text, {\n      delay,\n      ...options\n    });\n  }\n\n  return result;\n}\n\nasync function typeImpl(element, text, {\n  delay,\n  skipClick = false,\n  skipAutoClose = false,\n  initialSelectionStart,\n  initialSelectionEnd\n}) {\n  if (element.disabled) return;\n  if (!skipClick) (0, _click.click)(element);\n\n  if ((0, _utils.isContentEditable)(element) && document.getSelection().rangeCount === 0) {\n    const range = document.createRange();\n    range.setStart(element, 0);\n    range.setEnd(element, 0);\n    document.getSelection().addRange(range);\n  } // The focused element could change between each event, so get the currently active element each time\n\n\n  const currentElement = () => (0, _utils.getActiveElement)(element.ownerDocument); // by default, a new element has it's selection start and end at 0\n  // but most of the time when people call \"type\", they expect it to type\n  // at the end of the current input value. So, if the selection start\n  // and end are both the default of 0, then we'll go ahead and change\n  // them to the length of the current value.\n  // the only time it would make sense to pass the initialSelectionStart or\n  // initialSelectionEnd is if you have an input with a value and want to\n  // explicitely start typing with the cursor at 0. Not super common.\n\n\n  const value = (0, _utils.getValue)(currentElement());\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n\n  if (value != null && selectionStart === 0 && selectionEnd === 0) {\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), initialSelectionStart != null ? initialSelectionStart : value.length, initialSelectionEnd != null ? initialSelectionEnd : value.length);\n  }\n\n  const eventCallbacks = queueCallbacks();\n  await runCallbacks(eventCallbacks);\n\n  function queueCallbacks() {\n    const callbacks = [];\n    let remainingString = text;\n\n    while (remainingString) {\n      const {\n        callback,\n        remainingString: newRemainingString\n      } = getNextCallback(remainingString, skipAutoClose);\n      callbacks.push(callback);\n      remainingString = newRemainingString;\n    }\n\n    return callbacks;\n  }\n\n  async function runCallbacks(callbacks) {\n    const eventOverrides = {};\n    let prevWasMinus, prevWasPeriod, prevValue, typedValue;\n\n    for (const callback of callbacks) {\n      if (delay > 0) await wait(delay);\n\n      if (!currentElement().disabled) {\n        const returnValue = callback({\n          currentElement,\n          prevWasMinus,\n          prevWasPeriod,\n          prevValue,\n          eventOverrides,\n          typedValue\n        });\n        Object.assign(eventOverrides, returnValue == null ? void 0 : returnValue.eventOverrides);\n        prevWasMinus = returnValue == null ? void 0 : returnValue.prevWasMinus;\n        prevWasPeriod = returnValue == null ? void 0 : returnValue.prevWasPeriod;\n        prevValue = returnValue == null ? void 0 : returnValue.prevValue;\n        typedValue = returnValue == null ? void 0 : returnValue.typedValue;\n      }\n    }\n  }\n}\n\nfunction getNextCallback(remainingString, skipAutoClose) {\n  const modifierCallback = getModifierCallback(remainingString, skipAutoClose);\n\n  if (modifierCallback) {\n    return modifierCallback;\n  }\n\n  const specialCharCallback = getSpecialCharCallback(remainingString);\n\n  if (specialCharCallback) {\n    return specialCharCallback;\n  }\n\n  return getTypeCallback(remainingString);\n}\n\nfunction getModifierCallback(remainingString, skipAutoClose) {\n  const modifierKey = Object.keys(modifierCallbackMap).find(key => remainingString.startsWith(key));\n\n  if (!modifierKey) {\n    return null;\n  }\n\n  const callback = modifierCallbackMap[modifierKey]; // if this modifier has an associated \"close\" callback and the developer\n  // doesn't close it themselves, then we close it for them automatically\n  // Effectively if they send in: '{alt}a' then we type: '{alt}a{/alt}'\n\n  if (!skipAutoClose && callback.closeName && !remainingString.includes(callback.closeName)) {\n    remainingString += callback.closeName;\n  }\n\n  remainingString = remainingString.slice(modifierKey.length);\n  return {\n    callback,\n    remainingString\n  };\n}\n\nfunction getSpecialCharCallback(remainingString) {\n  const specialChar = Object.keys(specialCharCallbackMap).find(key => remainingString.startsWith(key));\n\n  if (!specialChar) {\n    return null;\n  }\n\n  return {\n    callback: specialCharCallbackMap[specialChar],\n    remainingString: remainingString.slice(specialChar.length)\n  };\n}\n\nfunction getTypeCallback(remainingString) {\n  const character = remainingString[0];\n\n  const callback = context => typeCharacter(character, context);\n\n  return {\n    callback,\n    remainingString: remainingString.slice(1)\n  };\n}\n\nfunction setSelectionRange({\n  currentElement,\n  newValue,\n  newSelectionStart\n}) {\n  // if we *can* change the selection start, then we will if the new value\n  // is the same as the current value (so it wasn't programatically changed\n  // when the fireEvent.input was triggered).\n  // The reason we have to do this at all is because it actually *is*\n  // programmatically changed by fireEvent.input, so we have to simulate the\n  // browser's default behavior\n  const value = (0, _utils.getValue)(currentElement());\n\n  if (value === newValue) {\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), newSelectionStart, newSelectionStart);\n  } else {\n    // If the currentValue is different than the expected newValue and we *can*\n    // change the selection range, than we should set it to the length of the\n    // currentValue to ensure that the browser behavior is mimicked.\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), value.length, value.length);\n  }\n}\n\nfunction fireInputEventIfNeeded({\n  currentElement,\n  newValue,\n  newSelectionStart,\n  eventOverrides\n}) {\n  const prevValue = (0, _utils.getValue)(currentElement());\n\n  if (!currentElement().readOnly && !(0, _utils.isClickableInput)(currentElement()) && newValue !== prevValue) {\n    if ((0, _utils.isContentEditable)(currentElement())) {\n      _dom.fireEvent.input(currentElement(), {\n        target: {\n          textContent: newValue\n        },\n        ...eventOverrides\n      });\n    } else {\n      _dom.fireEvent.input(currentElement(), {\n        target: {\n          value: newValue\n        },\n        ...eventOverrides\n      });\n    }\n\n    setSelectionRange({\n      currentElement,\n      newValue,\n      newSelectionStart\n    });\n  }\n\n  return {\n    prevValue\n  };\n}\n\nfunction typeCharacter(char, {\n  currentElement,\n  prevWasMinus = false,\n  prevWasPeriod = false,\n  prevValue = '',\n  typedValue = '',\n  eventOverrides\n}) {\n  const key = char; // TODO: check if this also valid for characters with diacritic markers e.g. úé etc\n\n  const keyCode = char.charCodeAt(0);\n  let nextPrevWasMinus, nextPrevWasPeriod;\n  const textToBeTyped = typedValue + char;\n\n  const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented) {\n    const keyPressDefaultNotPrevented = _dom.fireEvent.keyPress(currentElement(), {\n      key,\n      keyCode,\n      charCode: keyCode,\n      ...eventOverrides\n    });\n\n    if ((0, _utils.getValue)(currentElement()) != null && keyPressDefaultNotPrevented) {\n      let newEntry = char;\n\n      if (prevWasMinus) {\n        newEntry = `-${char}`;\n      } else if (prevWasPeriod) {\n        newEntry = `${prevValue}.${char}`;\n      }\n\n      if ((0, _utils.isValidDateValue)(currentElement(), textToBeTyped)) {\n        newEntry = textToBeTyped;\n      }\n\n      const timeNewEntry = (0, _utils.buildTimeValue)(textToBeTyped);\n\n      if ((0, _utils.isValidInputTimeValue)(currentElement(), timeNewEntry)) {\n        newEntry = timeNewEntry;\n      }\n\n      const inputEvent = fireInputEventIfNeeded({ ...(0, _utils.calculateNewValue)(newEntry, currentElement()),\n        eventOverrides: {\n          data: key,\n          inputType: 'insertText',\n          ...eventOverrides\n        },\n        currentElement\n      });\n      prevValue = inputEvent.prevValue;\n\n      if ((0, _utils.isValidDateValue)(currentElement(), textToBeTyped)) {\n        _dom.fireEvent.change(currentElement(), {\n          target: {\n            value: textToBeTyped\n          }\n        });\n      }\n\n      fireChangeForInputTimeIfValid(currentElement, prevValue, timeNewEntry); // typing \"-\" into a number input will not actually update the value\n      // so for the next character we type, the value should be set to\n      // `-${newEntry}`\n      // we also preserve the prevWasMinus when the value is unchanged due\n      // to typing an invalid character (typing \"-a3\" results in \"-3\")\n      // same applies for the decimal character.\n\n      if (currentElement().type === 'number') {\n        const newValue = (0, _utils.getValue)(currentElement());\n\n        if (newValue === prevValue && newEntry !== '-') {\n          nextPrevWasMinus = prevWasMinus;\n        } else {\n          nextPrevWasMinus = newEntry === '-';\n        }\n\n        if (newValue === prevValue && newEntry !== '.') {\n          nextPrevWasPeriod = prevWasPeriod;\n        } else {\n          nextPrevWasPeriod = newEntry === '.';\n        }\n      }\n    }\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  return {\n    prevWasMinus: nextPrevWasMinus,\n    prevWasPeriod: nextPrevWasPeriod,\n    prevValue,\n    typedValue: textToBeTyped\n  };\n}\n\nfunction fireChangeForInputTimeIfValid(currentElement, prevValue, timeNewEntry) {\n  if ((0, _utils.isValidInputTimeValue)(currentElement(), timeNewEntry) && prevValue !== timeNewEntry) {\n    _dom.fireEvent.change(currentElement(), {\n      target: {\n        value: timeNewEntry\n      }\n    });\n  }\n} // yes, calculateNewBackspaceValue and calculateNewValue look extremely similar\n// and you may be tempted to create a shared abstraction.\n// If you, brave soul, decide to so endevor, please increment this count\n// when you inevitably fail: 1\n\n\nfunction calculateNewBackspaceValue(element) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n  const value = (0, _utils.getValue)(element);\n  let newValue, newSelectionStart;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value.slice(0, value.length - 1);\n    newSelectionStart = selectionStart - 1;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = value;\n      newSelectionStart = selectionStart;\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value.slice(0, value.length - 1);\n      newSelectionStart = selectionStart - 1;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart - 1) + value.slice(selectionEnd);\n      newSelectionStart = selectionStart - 1;\n    }\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart);\n    newValue = firstPart + value.slice(selectionEnd);\n    newSelectionStart = firstPart.length;\n  }\n\n  return {\n    newValue,\n    newSelectionStart\n  };\n}\n\nfunction calculateNewDeleteValue(element) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n  const value = (0, _utils.getValue)(element);\n  let newValue;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = value.slice(1);\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart) + value.slice(selectionEnd + 1);\n    }\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart);\n    newValue = firstPart + value.slice(selectionEnd);\n  }\n\n  return {\n    newValue,\n    newSelectionStart: selectionStart\n  };\n}\n\nfunction createModifierCallbackEntries({\n  name,\n  key,\n  keyCode,\n  modifierProperty\n}) {\n  const openName = `{${name}}`;\n  const closeName = `{/${name}}`;\n\n  function open({\n    currentElement,\n    eventOverrides\n  }) {\n    const newEventOverrides = {\n      [modifierProperty]: true\n    };\n\n    _dom.fireEvent.keyDown(currentElement(), {\n      key,\n      keyCode,\n      which: keyCode,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    return {\n      eventOverrides: newEventOverrides\n    };\n  }\n\n  open.closeName = closeName;\n\n  function close({\n    currentElement,\n    eventOverrides\n  }) {\n    const newEventOverrides = {\n      [modifierProperty]: false\n    };\n\n    _dom.fireEvent.keyUp(currentElement(), {\n      key,\n      keyCode,\n      which: keyCode,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    return {\n      eventOverrides: newEventOverrides\n    };\n  }\n\n  return {\n    [openName]: open,\n    [closeName]: close\n  };\n}\n\nfunction handleEnter({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'Enter';\n  const keyCode = 13;\n\n  const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented) {\n    const keyPressDefaultNotPrevented = _dom.fireEvent.keyPress(currentElement(), {\n      key,\n      keyCode,\n      charCode: keyCode,\n      ...eventOverrides\n    });\n\n    if (keyPressDefaultNotPrevented) {\n      if ((0, _utils.isClickableInput)(currentElement()) || // Links with href defined should handle Enter the same as a click\n      (0, _utils.isInstanceOfElement)(currentElement(), 'HTMLAnchorElement') && currentElement().href) {\n        _dom.fireEvent.click(currentElement(), { ...eventOverrides\n        });\n      }\n\n      if (currentElement().tagName === 'TEXTAREA') {\n        const {\n          newValue,\n          newSelectionStart\n        } = (0, _utils.calculateNewValue)('\\n', currentElement());\n\n        _dom.fireEvent.input(currentElement(), {\n          target: {\n            value: newValue\n          },\n          inputType: 'insertLineBreak',\n          ...eventOverrides\n        });\n\n        setSelectionRange({\n          currentElement,\n          newValue,\n          newSelectionStart\n        });\n      }\n\n      if (currentElement().tagName === 'INPUT' && currentElement().form && (currentElement().form.querySelectorAll('input').length === 1 || currentElement().form.querySelector('input[type=\"submit\"]') || currentElement().form.querySelector('button[type=\"submit\"]'))) {\n        _dom.fireEvent.submit(currentElement().form);\n      }\n    }\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleEsc({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'Escape';\n  const keyCode = 27;\n\n  _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  }); // NOTE: Browsers do not fire a keypress on meta key presses\n\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleDel({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'Delete';\n  const keyCode = 46;\n\n  const keyPressDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyPressDefaultNotPrevented) {\n    fireInputEventIfNeeded({ ...calculateNewDeleteValue(currentElement()),\n      eventOverrides: {\n        inputType: 'deleteContentForward',\n        ...eventOverrides\n      },\n      currentElement\n    });\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleBackspace({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'Backspace';\n  const keyCode = 8;\n\n  const keyPressDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyPressDefaultNotPrevented) {\n    fireInputEventIfNeeded({ ...calculateNewBackspaceValue(currentElement()),\n      eventOverrides: {\n        inputType: 'deleteContentBackward',\n        ...eventOverrides\n      },\n      currentElement\n    });\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleSelectall({\n  currentElement\n}) {\n  currentElement().setSelectionRange(0, (0, _utils.getValue)(currentElement()).length);\n}\n\nfunction handleSpace(context) {\n  if ((0, _utils.isClickableInput)(context.currentElement())) {\n    handleSpaceOnClickable(context);\n    return;\n  }\n\n  typeCharacter(' ', context);\n}\n\nfunction handleSpaceOnClickable({\n  currentElement,\n  eventOverrides\n}) {\n  const key = ' ';\n  const keyCode = 32;\n\n  const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented) {\n    _dom.fireEvent.keyPress(currentElement(), {\n      key,\n      keyCode,\n      charCode: keyCode,\n      ...eventOverrides\n    });\n  }\n\n  const keyUpDefaultNotPrevented = _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented && keyUpDefaultNotPrevented) {\n    _dom.fireEvent.click(currentElement(), { ...eventOverrides\n    });\n  }\n}\n\nfunction handleArrowDown({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'ArrowDown';\n  const keyCode = 40;\n\n  _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleArrowUp({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'ArrowUp';\n  const keyCode = 38;\n\n  _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,IAAI,GAAGA,IAAI;AACnBF,OAAO,CAACG,cAAc,GAAG,KAAK,CAAC;AAE/B,IAAIC,IAAI,GAAGC,OAAO,CAAC,sBAAsB,CAAC;AAE1C,IAAIC,MAAM,GAAGD,OAAO,CAAC,SAAS,CAAC;AAE/B,IAAIE,MAAM,GAAGF,OAAO,CAAC,SAAS,CAAC;AAE/B,IAAIG,cAAc,GAAGH,OAAO,CAAC,uBAAuB,CAAC;;AAErD;AACA,MAAMI,mBAAmB,GAAG;EAAE,GAAGC,6BAA6B,CAAC;IAC3DC,IAAI,EAAE,OAAO;IACbC,GAAG,EAAE,OAAO;IACZC,OAAO,EAAE,EAAE;IACXC,gBAAgB,EAAE;EACpB,CAAC,CAAC;EACF,GAAGJ,6BAA6B,CAAC;IAC/BC,IAAI,EAAE,MAAM;IACZC,GAAG,EAAE,SAAS;IACdC,OAAO,EAAE,EAAE;IACXC,gBAAgB,EAAE;EACpB,CAAC,CAAC;EACF,GAAGJ,6BAA6B,CAAC;IAC/BC,IAAI,EAAE,KAAK;IACXC,GAAG,EAAE,KAAK;IACVC,OAAO,EAAE,EAAE;IACXC,gBAAgB,EAAE;EACpB,CAAC,CAAC;EACF,GAAGJ,6BAA6B,CAAC;IAC/BC,IAAI,EAAE,MAAM;IACZC,GAAG,EAAE,MAAM;IACXC,OAAO,EAAE,EAAE;IACXC,gBAAgB,EAAE;EACpB,CAAC,CAAC;EACF;EACA,YAAY,EAAE,SAASC,UAAUA,CAAAC,IAAA,EAG9B;IAAA,IAH+B;MAChCC,cAAc;MACdC;IACF,CAAC,GAAAF,IAAA;IACC,MAAMG,iBAAiB,GAAG;MACxBC,gBAAgB,EAAE;IACpB,CAAC;IAEDhB,IAAI,CAACiB,SAAS,CAACC,OAAO,CAACL,cAAc,EAAE,EAAE;MACvCL,GAAG,EAAE,UAAU;MACfC,OAAO,EAAE,EAAE;MACXU,KAAK,EAAE,EAAE;MACT,GAAGL,cAAc;MACjB,GAAGC;IACL,CAAC,CAAC;IAEFf,IAAI,CAACiB,SAAS,CAACG,KAAK,CAACP,cAAc,EAAE,EAAE;MACrCL,GAAG,EAAE,UAAU;MACfC,OAAO,EAAE,EAAE;MACXU,KAAK,EAAE,EAAE;MACT,GAAGL,cAAc;MACjB,GAAGC;IACL,CAAC,CAAC;IAEF,OAAO;MACLD,cAAc,EAAEC;IAClB,CAAC;EACH,CAAC;EACD,aAAa,EAAE,SAASM,WAAWA,CAAAC,KAAA,EAGhC;IAAA,IAHiC;MAClCT,cAAc;MACdC;IACF,CAAC,GAAAQ,KAAA;IACC,MAAMP,iBAAiB,GAAG;MACxBC,gBAAgB,EAAE;IACpB,CAAC;IAEDhB,IAAI,CAACiB,SAAS,CAACC,OAAO,CAACL,cAAc,EAAE,EAAE;MACvCL,GAAG,EAAE,UAAU;MACfC,OAAO,EAAE,EAAE;MACXU,KAAK,EAAE,EAAE;MACT,GAAGL,cAAc;MACjB,GAAGC;IACL,CAAC,CAAC;IAEFf,IAAI,CAACiB,SAAS,CAACG,KAAK,CAACP,cAAc,EAAE,EAAE;MACrCL,GAAG,EAAE,UAAU;MACfC,OAAO,EAAE,EAAE;MACXU,KAAK,EAAE,EAAE;MACT,GAAGL,cAAc;MACjB,GAAGC;IACL,CAAC,CAAC;IAEF,OAAO;MACLD,cAAc,EAAEC;IAClB,CAAC;EACH;AACF,CAAC;AACD,MAAMhB,cAAc,GAAG;EACrBwB,SAAS,EAAE,aAAa;EACxBC,UAAU,EAAE,cAAc;EAC1BC,SAAS,EAAE,aAAa;EACxBC,OAAO,EAAE,WAAW;EACpBC,KAAK,EAAE,SAAS;EAChBC,MAAM,EAAE,OAAO;EACfC,MAAM,EAAE,OAAO;EACfC,SAAS,EAAE,aAAa;EACxBC,IAAI,EAAE,QAAQ;EACdC,GAAG,EAAE,OAAO;EACZC,SAAS,EAAE,aAAa;EACxBC,KAAK,EAAE,SAAS;EAChBC,UAAU,EAAE;AACd,CAAC;AACDvC,OAAO,CAACG,cAAc,GAAGA,cAAc;AACvC,MAAMqC,sBAAsB,GAAG;EAC7B,CAACrC,cAAc,CAACwB,SAAS,GAAG,CAAC,CAAC,EAAEnB,cAAc,CAACiC,aAAa,EAAE,WAAW,CAAC;EAC1E,CAACtC,cAAc,CAACyB,UAAU,GAAG,CAAC,CAAC,EAAEpB,cAAc,CAACiC,aAAa,EAAE,YAAY,CAAC;EAC5E,CAACtC,cAAc,CAAC0B,SAAS,GAAGa,eAAe;EAC3C,CAACvC,cAAc,CAAC2B,OAAO,GAAGa,aAAa;EACvC,CAACxC,cAAc,CAACgC,IAAI,GAAG,CAAC,CAAC,EAAE3B,cAAc,CAACiC,aAAa,EAAE,MAAM,CAAC;EAChE,CAACtC,cAAc,CAACiC,GAAG,GAAG,CAAC,CAAC,EAAE5B,cAAc,CAACiC,aAAa,EAAE,KAAK,CAAC;EAC9D,CAACtC,cAAc,CAAC4B,KAAK,GAAGa,WAAW;EACnC,CAACzC,cAAc,CAAC6B,MAAM,GAAGa,SAAS;EAClC,CAAC1C,cAAc,CAAC8B,MAAM,GAAGa,SAAS;EAClC,CAAC3C,cAAc,CAAC+B,SAAS,GAAGa,eAAe;EAC3C,CAAC5C,cAAc,CAACkC,SAAS,GAAGW,eAAe;EAC3C,CAAC7C,cAAc,CAACmC,KAAK,GAAGW,WAAW;EACnC,CAAC9C,cAAc,CAACoC,UAAU,GAAGU;AAC/B,CAAC;AAED,SAASC,IAAIA,CAACC,IAAI,EAAE;EAClB,OAAO,IAAIC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAAC,MAAMD,OAAO,EAAE,EAAEF,IAAI,CAAC,CAAC;AAClE,CAAC,CAAC;AACF;;AAGA,eAAejD,IAAIA,CAACqD,OAAO,EAAEC,IAAI,EAGzB;EAAA,IAH2B;IACjCC,KAAK,GAAG,CAAC;IACT,GAAGC;EACL,CAAC,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EACJ;EACA;EACA;EACA,IAAIG,MAAM;EAEV,IAAIL,KAAK,GAAG,CAAC,EAAE;IACb,MAAM,CAAC,CAAC,EAAErD,IAAI,CAAC2D,SAAS,GAAG,CAACC,YAAY,CAAC,YAAY;MACnDF,MAAM,GAAG,MAAMG,QAAQ,CAACV,OAAO,EAAEC,IAAI,EAAE;QACrCC,KAAK;QACL,GAAGC;MACL,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC,MAAM;IACLI,MAAM,GAAGG,QAAQ,CAACV,OAAO,EAAEC,IAAI,EAAE;MAC/BC,KAAK;MACL,GAAGC;IACL,CAAC,CAAC;EACJ;EAEA,OAAOI,MAAM;AACf;AAEA,eAAeG,QAAQA,CAACV,OAAO,EAAEC,IAAI,EAAAU,KAAA,EAMlC;EAAA,IANoC;IACrCT,KAAK;IACLU,SAAS,GAAG,KAAK;IACjBC,aAAa,GAAG,KAAK;IACrBC,qBAAqB;IACrBC;EACF,CAAC,GAAAJ,KAAA;EACC,IAAIX,OAAO,CAACgB,QAAQ,EAAE;EACtB,IAAI,CAACJ,SAAS,EAAE,CAAC,CAAC,EAAE5D,MAAM,CAACiE,KAAK,EAAEjB,OAAO,CAAC;EAE1C,IAAI,CAAC,CAAC,EAAEjD,MAAM,CAACmE,iBAAiB,EAAElB,OAAO,CAAC,IAAImB,QAAQ,CAACC,YAAY,EAAE,CAACC,UAAU,KAAK,CAAC,EAAE;IACtF,MAAMC,KAAK,GAAGH,QAAQ,CAACI,WAAW,EAAE;IACpCD,KAAK,CAACE,QAAQ,CAACxB,OAAO,EAAE,CAAC,CAAC;IAC1BsB,KAAK,CAACG,MAAM,CAACzB,OAAO,EAAE,CAAC,CAAC;IACxBmB,QAAQ,CAACC,YAAY,EAAE,CAACM,QAAQ,CAACJ,KAAK,CAAC;EACzC,CAAC,CAAC;;EAGF,MAAM5D,cAAc,GAAGA,CAAA,KAAM,CAAC,CAAC,EAAEX,MAAM,CAAC4E,gBAAgB,EAAE3B,OAAO,CAAC4B,aAAa,CAAC,CAAC,CAAC;EAClF;EACA;EACA;EACA;EACA;EACA;EACA;;EAGA,MAAMlF,KAAK,GAAG,CAAC,CAAC,EAAEK,MAAM,CAAC8E,QAAQ,EAAEnE,cAAc,EAAE,CAAC;EACpD,MAAM;IACJoE,cAAc;IACdC;EACF,CAAC,GAAG,CAAC,CAAC,EAAEhF,MAAM,CAACiF,iBAAiB,EAAEhC,OAAO,CAAC;EAE1C,IAAItD,KAAK,IAAI,IAAI,IAAIoF,cAAc,KAAK,CAAC,IAAIC,YAAY,KAAK,CAAC,EAAE;IAC/D,CAAC,CAAC,EAAEhF,MAAM,CAACkF,4BAA4B,EAAEvE,cAAc,EAAE,EAAEoD,qBAAqB,IAAI,IAAI,GAAGA,qBAAqB,GAAGpE,KAAK,CAAC2D,MAAM,EAAEU,mBAAmB,IAAI,IAAI,GAAGA,mBAAmB,GAAGrE,KAAK,CAAC2D,MAAM,CAAC;EACpM;EAEA,MAAM6B,cAAc,GAAGC,cAAc,EAAE;EACvC,MAAMC,YAAY,CAACF,cAAc,CAAC;EAElC,SAASC,cAAcA,CAAA,EAAG;IACxB,MAAME,SAAS,GAAG,EAAE;IACpB,IAAIC,eAAe,GAAGrC,IAAI;IAE1B,OAAOqC,eAAe,EAAE;MACtB,MAAM;QACJC,QAAQ;QACRD,eAAe,EAAEE;MACnB,CAAC,GAAGC,eAAe,CAACH,eAAe,EAAEzB,aAAa,CAAC;MACnDwB,SAAS,CAACK,IAAI,CAACH,QAAQ,CAAC;MACxBD,eAAe,GAAGE,kBAAkB;IACtC;IAEA,OAAOH,SAAS;EAClB;EAEA,eAAeD,YAAYA,CAACC,SAAS,EAAE;IACrC,MAAM1E,cAAc,GAAG,CAAC,CAAC;IACzB,IAAIgF,YAAY,EAAEC,aAAa,EAAEC,SAAS,EAAEC,UAAU;IAEtD,KAAK,MAAMP,QAAQ,IAAIF,SAAS,EAAE;MAChC,IAAInC,KAAK,GAAG,CAAC,EAAE,MAAMP,IAAI,CAACO,KAAK,CAAC;MAEhC,IAAI,CAACxC,cAAc,EAAE,CAACsD,QAAQ,EAAE;QAC9B,MAAM+B,WAAW,GAAGR,QAAQ,CAAC;UAC3B7E,cAAc;UACdiF,YAAY;UACZC,aAAa;UACbC,SAAS;UACTlF,cAAc;UACdmF;QACF,CAAC,CAAC;QACFvG,MAAM,CAACyG,MAAM,CAACrF,cAAc,EAAEoF,WAAW,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,WAAW,CAACpF,cAAc,CAAC;QACxFgF,YAAY,GAAGI,WAAW,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,WAAW,CAACJ,YAAY;QACtEC,aAAa,GAAGG,WAAW,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,WAAW,CAACH,aAAa;QACxEC,SAAS,GAAGE,WAAW,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,WAAW,CAACF,SAAS;QAChEC,UAAU,GAAGC,WAAW,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,WAAW,CAACD,UAAU;MACpE;IACF;EACF;AACF;AAEA,SAASL,eAAeA,CAACH,eAAe,EAAEzB,aAAa,EAAE;EACvD,MAAMoC,gBAAgB,GAAGC,mBAAmB,CAACZ,eAAe,EAAEzB,aAAa,CAAC;EAE5E,IAAIoC,gBAAgB,EAAE;IACpB,OAAOA,gBAAgB;EACzB;EAEA,MAAME,mBAAmB,GAAGC,sBAAsB,CAACd,eAAe,CAAC;EAEnE,IAAIa,mBAAmB,EAAE;IACvB,OAAOA,mBAAmB;EAC5B;EAEA,OAAOE,eAAe,CAACf,eAAe,CAAC;AACzC;AAEA,SAASY,mBAAmBA,CAACZ,eAAe,EAAEzB,aAAa,EAAE;EAC3D,MAAMyC,WAAW,GAAG/G,MAAM,CAACgH,IAAI,CAACrG,mBAAmB,CAAC,CAACsG,IAAI,CAACnG,GAAG,IAAIiF,eAAe,CAACmB,UAAU,CAACpG,GAAG,CAAC,CAAC;EAEjG,IAAI,CAACiG,WAAW,EAAE;IAChB,OAAO,IAAI;EACb;EAEA,MAAMf,QAAQ,GAAGrF,mBAAmB,CAACoG,WAAW,CAAC,CAAC,CAAC;EACnD;EACA;;EAEA,IAAI,CAACzC,aAAa,IAAI0B,QAAQ,CAACmB,SAAS,IAAI,CAACpB,eAAe,CAACqB,QAAQ,CAACpB,QAAQ,CAACmB,SAAS,CAAC,EAAE;IACzFpB,eAAe,IAAIC,QAAQ,CAACmB,SAAS;EACvC;EAEApB,eAAe,GAAGA,eAAe,CAACsB,KAAK,CAACN,WAAW,CAACjD,MAAM,CAAC;EAC3D,OAAO;IACLkC,QAAQ;IACRD;EACF,CAAC;AACH;AAEA,SAASc,sBAAsBA,CAACd,eAAe,EAAE;EAC/C,MAAMuB,WAAW,GAAGtH,MAAM,CAACgH,IAAI,CAACtE,sBAAsB,CAAC,CAACuE,IAAI,CAACnG,GAAG,IAAIiF,eAAe,CAACmB,UAAU,CAACpG,GAAG,CAAC,CAAC;EAEpG,IAAI,CAACwG,WAAW,EAAE;IAChB,OAAO,IAAI;EACb;EAEA,OAAO;IACLtB,QAAQ,EAAEtD,sBAAsB,CAAC4E,WAAW,CAAC;IAC7CvB,eAAe,EAAEA,eAAe,CAACsB,KAAK,CAACC,WAAW,CAACxD,MAAM;EAC3D,CAAC;AACH;AAEA,SAASgD,eAAeA,CAACf,eAAe,EAAE;EACxC,MAAMwB,SAAS,GAAGxB,eAAe,CAAC,CAAC,CAAC;EAEpC,MAAMC,QAAQ,GAAGwB,OAAO,IAAIC,aAAa,CAACF,SAAS,EAAEC,OAAO,CAAC;EAE7D,OAAO;IACLxB,QAAQ;IACRD,eAAe,EAAEA,eAAe,CAACsB,KAAK,CAAC,CAAC;EAC1C,CAAC;AACH;AAEA,SAASK,iBAAiBA,CAAAC,KAAA,EAIvB;EAAA,IAJwB;IACzBxG,cAAc;IACdyG,QAAQ;IACRC;EACF,CAAC,GAAAF,KAAA;EACC;EACA;EACA;EACA;EACA;EACA;EACA,MAAMxH,KAAK,GAAG,CAAC,CAAC,EAAEK,MAAM,CAAC8E,QAAQ,EAAEnE,cAAc,EAAE,CAAC;EAEpD,IAAIhB,KAAK,KAAKyH,QAAQ,EAAE;IACtB,CAAC,CAAC,EAAEpH,MAAM,CAACkF,4BAA4B,EAAEvE,cAAc,EAAE,EAAE0G,iBAAiB,EAAEA,iBAAiB,CAAC;EAClG,CAAC,MAAM;IACL;IACA;IACA;IACA,CAAC,CAAC,EAAErH,MAAM,CAACkF,4BAA4B,EAAEvE,cAAc,EAAE,EAAEhB,KAAK,CAAC2D,MAAM,EAAE3D,KAAK,CAAC2D,MAAM,CAAC;EACxF;AACF;AAEA,SAASgE,sBAAsBA,CAAAC,KAAA,EAK5B;EAAA,IAL6B;IAC9B5G,cAAc;IACdyG,QAAQ;IACRC,iBAAiB;IACjBzG;EACF,CAAC,GAAA2G,KAAA;EACC,MAAMzB,SAAS,GAAG,CAAC,CAAC,EAAE9F,MAAM,CAAC8E,QAAQ,EAAEnE,cAAc,EAAE,CAAC;EAExD,IAAI,CAACA,cAAc,EAAE,CAAC6G,QAAQ,IAAI,CAAC,CAAC,CAAC,EAAExH,MAAM,CAACyH,gBAAgB,EAAE9G,cAAc,EAAE,CAAC,IAAIyG,QAAQ,KAAKtB,SAAS,EAAE;IAC3G,IAAI,CAAC,CAAC,EAAE9F,MAAM,CAACmE,iBAAiB,EAAExD,cAAc,EAAE,CAAC,EAAE;MACnDb,IAAI,CAACiB,SAAS,CAAC2G,KAAK,CAAC/G,cAAc,EAAE,EAAE;QACrCgH,MAAM,EAAE;UACNC,WAAW,EAAER;QACf,CAAC;QACD,GAAGxG;MACL,CAAC,CAAC;IACJ,CAAC,MAAM;MACLd,IAAI,CAACiB,SAAS,CAAC2G,KAAK,CAAC/G,cAAc,EAAE,EAAE;QACrCgH,MAAM,EAAE;UACNhI,KAAK,EAAEyH;QACT,CAAC;QACD,GAAGxG;MACL,CAAC,CAAC;IACJ;IAEAsG,iBAAiB,CAAC;MAChBvG,cAAc;MACdyG,QAAQ;MACRC;IACF,CAAC,CAAC;EACJ;EAEA,OAAO;IACLvB;EACF,CAAC;AACH;AAEA,SAASmB,aAAaA,CAACY,IAAI,EAAAC,KAAA,EAOxB;EAAA,IAP0B;IAC3BnH,cAAc;IACdiF,YAAY,GAAG,KAAK;IACpBC,aAAa,GAAG,KAAK;IACrBC,SAAS,GAAG,EAAE;IACdC,UAAU,GAAG,EAAE;IACfnF;EACF,CAAC,GAAAkH,KAAA;EACC,MAAMxH,GAAG,GAAGuH,IAAI,CAAC,CAAC;;EAElB,MAAMtH,OAAO,GAAGsH,IAAI,CAACE,UAAU,CAAC,CAAC,CAAC;EAClC,IAAIC,gBAAgB,EAAEC,iBAAiB;EACvC,MAAMC,aAAa,GAAGnC,UAAU,GAAG8B,IAAI;EAEvC,MAAMM,0BAA0B,GAAGrI,IAAI,CAACiB,SAAS,CAACC,OAAO,CAACL,cAAc,EAAE,EAAE;IAC1EL,GAAG;IACHC,OAAO;IACPU,KAAK,EAAEV,OAAO;IACd,GAAGK;EACL,CAAC,CAAC;EAEF,IAAIuH,0BAA0B,EAAE;IAC9B,MAAMC,2BAA2B,GAAGtI,IAAI,CAACiB,SAAS,CAACsH,QAAQ,CAAC1H,cAAc,EAAE,EAAE;MAC5EL,GAAG;MACHC,OAAO;MACP+H,QAAQ,EAAE/H,OAAO;MACjB,GAAGK;IACL,CAAC,CAAC;IAEF,IAAI,CAAC,CAAC,EAAEZ,MAAM,CAAC8E,QAAQ,EAAEnE,cAAc,EAAE,CAAC,IAAI,IAAI,IAAIyH,2BAA2B,EAAE;MACjF,IAAIG,QAAQ,GAAGV,IAAI;MAEnB,IAAIjC,YAAY,EAAE;QAChB2C,QAAQ,GAAI,IAAGV,IAAK,EAAC;MACvB,CAAC,MAAM,IAAIhC,aAAa,EAAE;QACxB0C,QAAQ,GAAI,GAAEzC,SAAU,IAAG+B,IAAK,EAAC;MACnC;MAEA,IAAI,CAAC,CAAC,EAAE7H,MAAM,CAACwI,gBAAgB,EAAE7H,cAAc,EAAE,EAAEuH,aAAa,CAAC,EAAE;QACjEK,QAAQ,GAAGL,aAAa;MAC1B;MAEA,MAAMO,YAAY,GAAG,CAAC,CAAC,EAAEzI,MAAM,CAAC0I,cAAc,EAAER,aAAa,CAAC;MAE9D,IAAI,CAAC,CAAC,EAAElI,MAAM,CAAC2I,qBAAqB,EAAEhI,cAAc,EAAE,EAAE8H,YAAY,CAAC,EAAE;QACrEF,QAAQ,GAAGE,YAAY;MACzB;MAEA,MAAMG,UAAU,GAAGtB,sBAAsB,CAAC;QAAE,GAAG,CAAC,CAAC,EAAEtH,MAAM,CAAC6I,iBAAiB,EAAEN,QAAQ,EAAE5H,cAAc,EAAE,CAAC;QACtGC,cAAc,EAAE;UACdkI,IAAI,EAAExI,GAAG;UACTyI,SAAS,EAAE,YAAY;UACvB,GAAGnI;QACL,CAAC;QACDD;MACF,CAAC,CAAC;MACFmF,SAAS,GAAG8C,UAAU,CAAC9C,SAAS;MAEhC,IAAI,CAAC,CAAC,EAAE9F,MAAM,CAACwI,gBAAgB,EAAE7H,cAAc,EAAE,EAAEuH,aAAa,CAAC,EAAE;QACjEpI,IAAI,CAACiB,SAAS,CAACiI,MAAM,CAACrI,cAAc,EAAE,EAAE;UACtCgH,MAAM,EAAE;YACNhI,KAAK,EAAEuI;UACT;QACF,CAAC,CAAC;MACJ;MAEAe,6BAA6B,CAACtI,cAAc,EAAEmF,SAAS,EAAE2C,YAAY,CAAC,CAAC,CAAC;MACxE;MACA;MACA;MACA;MACA;;MAEA,IAAI9H,cAAc,EAAE,CAACf,IAAI,KAAK,QAAQ,EAAE;QACtC,MAAMwH,QAAQ,GAAG,CAAC,CAAC,EAAEpH,MAAM,CAAC8E,QAAQ,EAAEnE,cAAc,EAAE,CAAC;QAEvD,IAAIyG,QAAQ,KAAKtB,SAAS,IAAIyC,QAAQ,KAAK,GAAG,EAAE;UAC9CP,gBAAgB,GAAGpC,YAAY;QACjC,CAAC,MAAM;UACLoC,gBAAgB,GAAGO,QAAQ,KAAK,GAAG;QACrC;QAEA,IAAInB,QAAQ,KAAKtB,SAAS,IAAIyC,QAAQ,KAAK,GAAG,EAAE;UAC9CN,iBAAiB,GAAGpC,aAAa;QACnC,CAAC,MAAM;UACLoC,iBAAiB,GAAGM,QAAQ,KAAK,GAAG;QACtC;MACF;IACF;EACF;EAEAzI,IAAI,CAACiB,SAAS,CAACG,KAAK,CAACP,cAAc,EAAE,EAAE;IACrCL,GAAG;IACHC,OAAO;IACPU,KAAK,EAAEV,OAAO;IACd,GAAGK;EACL,CAAC,CAAC;EAEF,OAAO;IACLgF,YAAY,EAAEoC,gBAAgB;IAC9BnC,aAAa,EAAEoC,iBAAiB;IAChCnC,SAAS;IACTC,UAAU,EAAEmC;EACd,CAAC;AACH;AAEA,SAASe,6BAA6BA,CAACtI,cAAc,EAAEmF,SAAS,EAAE2C,YAAY,EAAE;EAC9E,IAAI,CAAC,CAAC,EAAEzI,MAAM,CAAC2I,qBAAqB,EAAEhI,cAAc,EAAE,EAAE8H,YAAY,CAAC,IAAI3C,SAAS,KAAK2C,YAAY,EAAE;IACnG3I,IAAI,CAACiB,SAAS,CAACiI,MAAM,CAACrI,cAAc,EAAE,EAAE;MACtCgH,MAAM,EAAE;QACNhI,KAAK,EAAE8I;MACT;IACF,CAAC,CAAC;EACJ;AACF,CAAC,CAAC;AACF;AACA;AACA;;AAGA,SAASS,0BAA0BA,CAACjG,OAAO,EAAE;EAC3C,MAAM;IACJ8B,cAAc;IACdC;EACF,CAAC,GAAG,CAAC,CAAC,EAAEhF,MAAM,CAACiF,iBAAiB,EAAEhC,OAAO,CAAC;EAC1C,MAAMtD,KAAK,GAAG,CAAC,CAAC,EAAEK,MAAM,CAAC8E,QAAQ,EAAE7B,OAAO,CAAC;EAC3C,IAAImE,QAAQ,EAAEC,iBAAiB;EAE/B,IAAItC,cAAc,KAAK,IAAI,EAAE;IAC3B;IACA;IACAqC,QAAQ,GAAGzH,KAAK,CAACkH,KAAK,CAAC,CAAC,EAAElH,KAAK,CAAC2D,MAAM,GAAG,CAAC,CAAC;IAC3C+D,iBAAiB,GAAGtC,cAAc,GAAG,CAAC;EACxC,CAAC,MAAM,IAAIA,cAAc,KAAKC,YAAY,EAAE;IAC1C,IAAID,cAAc,KAAK,CAAC,EAAE;MACxB;MACAqC,QAAQ,GAAGzH,KAAK;MAChB0H,iBAAiB,GAAGtC,cAAc;IACpC,CAAC,MAAM,IAAIA,cAAc,KAAKpF,KAAK,CAAC2D,MAAM,EAAE;MAC1C;MACA8D,QAAQ,GAAGzH,KAAK,CAACkH,KAAK,CAAC,CAAC,EAAElH,KAAK,CAAC2D,MAAM,GAAG,CAAC,CAAC;MAC3C+D,iBAAiB,GAAGtC,cAAc,GAAG,CAAC;IACxC,CAAC,MAAM;MACL;MACAqC,QAAQ,GAAGzH,KAAK,CAACkH,KAAK,CAAC,CAAC,EAAE9B,cAAc,GAAG,CAAC,CAAC,GAAGpF,KAAK,CAACkH,KAAK,CAAC7B,YAAY,CAAC;MACzEqC,iBAAiB,GAAGtC,cAAc,GAAG,CAAC;IACxC;EACF,CAAC,MAAM;IACL;IACA,MAAMoE,SAAS,GAAGxJ,KAAK,CAACkH,KAAK,CAAC,CAAC,EAAE9B,cAAc,CAAC;IAChDqC,QAAQ,GAAG+B,SAAS,GAAGxJ,KAAK,CAACkH,KAAK,CAAC7B,YAAY,CAAC;IAChDqC,iBAAiB,GAAG8B,SAAS,CAAC7F,MAAM;EACtC;EAEA,OAAO;IACL8D,QAAQ;IACRC;EACF,CAAC;AACH;AAEA,SAAS+B,uBAAuBA,CAACnG,OAAO,EAAE;EACxC,MAAM;IACJ8B,cAAc;IACdC;EACF,CAAC,GAAG,CAAC,CAAC,EAAEhF,MAAM,CAACiF,iBAAiB,EAAEhC,OAAO,CAAC;EAC1C,MAAMtD,KAAK,GAAG,CAAC,CAAC,EAAEK,MAAM,CAAC8E,QAAQ,EAAE7B,OAAO,CAAC;EAC3C,IAAImE,QAAQ;EAEZ,IAAIrC,cAAc,KAAK,IAAI,EAAE;IAC3B;IACA;IACAqC,QAAQ,GAAGzH,KAAK;EAClB,CAAC,MAAM,IAAIoF,cAAc,KAAKC,YAAY,EAAE;IAC1C,IAAID,cAAc,KAAK,CAAC,EAAE;MACxB;MACAqC,QAAQ,GAAGzH,KAAK,CAACkH,KAAK,CAAC,CAAC,CAAC;IAC3B,CAAC,MAAM,IAAI9B,cAAc,KAAKpF,KAAK,CAAC2D,MAAM,EAAE;MAC1C;MACA8D,QAAQ,GAAGzH,KAAK;IAClB,CAAC,MAAM;MACL;MACAyH,QAAQ,GAAGzH,KAAK,CAACkH,KAAK,CAAC,CAAC,EAAE9B,cAAc,CAAC,GAAGpF,KAAK,CAACkH,KAAK,CAAC7B,YAAY,GAAG,CAAC,CAAC;IAC3E;EACF,CAAC,MAAM;IACL;IACA,MAAMmE,SAAS,GAAGxJ,KAAK,CAACkH,KAAK,CAAC,CAAC,EAAE9B,cAAc,CAAC;IAChDqC,QAAQ,GAAG+B,SAAS,GAAGxJ,KAAK,CAACkH,KAAK,CAAC7B,YAAY,CAAC;EAClD;EAEA,OAAO;IACLoC,QAAQ;IACRC,iBAAiB,EAAEtC;EACrB,CAAC;AACH;AAEA,SAAS3E,6BAA6BA,CAAAiJ,KAAA,EAKnC;EAAA,IALoC;IACrChJ,IAAI;IACJC,GAAG;IACHC,OAAO;IACPC;EACF,CAAC,GAAA6I,KAAA;EACC,MAAMC,QAAQ,GAAI,IAAGjJ,IAAK,GAAE;EAC5B,MAAMsG,SAAS,GAAI,KAAItG,IAAK,GAAE;EAE9B,SAASkJ,IAAIA,CAAAC,KAAA,EAGV;IAAA,IAHW;MACZ7I,cAAc;MACdC;IACF,CAAC,GAAA4I,KAAA;IACC,MAAM3I,iBAAiB,GAAG;MACxB,CAACL,gBAAgB,GAAG;IACtB,CAAC;IAEDV,IAAI,CAACiB,SAAS,CAACC,OAAO,CAACL,cAAc,EAAE,EAAE;MACvCL,GAAG;MACHC,OAAO;MACPU,KAAK,EAAEV,OAAO;MACd,GAAGK,cAAc;MACjB,GAAGC;IACL,CAAC,CAAC;IAEF,OAAO;MACLD,cAAc,EAAEC;IAClB,CAAC;EACH;EAEA0I,IAAI,CAAC5C,SAAS,GAAGA,SAAS;EAE1B,SAAS8C,KAAKA,CAAAC,KAAA,EAGX;IAAA,IAHY;MACb/I,cAAc;MACdC;IACF,CAAC,GAAA8I,KAAA;IACC,MAAM7I,iBAAiB,GAAG;MACxB,CAACL,gBAAgB,GAAG;IACtB,CAAC;IAEDV,IAAI,CAACiB,SAAS,CAACG,KAAK,CAACP,cAAc,EAAE,EAAE;MACrCL,GAAG;MACHC,OAAO;MACPU,KAAK,EAAEV,OAAO;MACd,GAAGK,cAAc;MACjB,GAAGC;IACL,CAAC,CAAC;IAEF,OAAO;MACLD,cAAc,EAAEC;IAClB,CAAC;EACH;EAEA,OAAO;IACL,CAACyI,QAAQ,GAAGC,IAAI;IAChB,CAAC5C,SAAS,GAAG8C;EACf,CAAC;AACH;AAEA,SAASnH,WAAWA,CAAAqH,MAAA,EAGjB;EAAA,IAHkB;IACnBhJ,cAAc;IACdC;EACF,CAAC,GAAA+I,MAAA;EACC,MAAMrJ,GAAG,GAAG,OAAO;EACnB,MAAMC,OAAO,GAAG,EAAE;EAElB,MAAM4H,0BAA0B,GAAGrI,IAAI,CAACiB,SAAS,CAACC,OAAO,CAACL,cAAc,EAAE,EAAE;IAC1EL,GAAG;IACHC,OAAO;IACPU,KAAK,EAAEV,OAAO;IACd,GAAGK;EACL,CAAC,CAAC;EAEF,IAAIuH,0BAA0B,EAAE;IAC9B,MAAMC,2BAA2B,GAAGtI,IAAI,CAACiB,SAAS,CAACsH,QAAQ,CAAC1H,cAAc,EAAE,EAAE;MAC5EL,GAAG;MACHC,OAAO;MACP+H,QAAQ,EAAE/H,OAAO;MACjB,GAAGK;IACL,CAAC,CAAC;IAEF,IAAIwH,2BAA2B,EAAE;MAC/B,IAAI,CAAC,CAAC,EAAEpI,MAAM,CAACyH,gBAAgB,EAAE9G,cAAc,EAAE,CAAC;MAAI;MACtD,CAAC,CAAC,EAAEX,MAAM,CAAC4J,mBAAmB,EAAEjJ,cAAc,EAAE,EAAE,mBAAmB,CAAC,IAAIA,cAAc,EAAE,CAACkJ,IAAI,EAAE;QAC/F/J,IAAI,CAACiB,SAAS,CAACmD,KAAK,CAACvD,cAAc,EAAE,EAAE;UAAE,GAAGC;QAC5C,CAAC,CAAC;MACJ;MAEA,IAAID,cAAc,EAAE,CAACmJ,OAAO,KAAK,UAAU,EAAE;QAC3C,MAAM;UACJ1C,QAAQ;UACRC;QACF,CAAC,GAAG,CAAC,CAAC,EAAErH,MAAM,CAAC6I,iBAAiB,EAAE,IAAI,EAAElI,cAAc,EAAE,CAAC;QAEzDb,IAAI,CAACiB,SAAS,CAAC2G,KAAK,CAAC/G,cAAc,EAAE,EAAE;UACrCgH,MAAM,EAAE;YACNhI,KAAK,EAAEyH;UACT,CAAC;UACD2B,SAAS,EAAE,iBAAiB;UAC5B,GAAGnI;QACL,CAAC,CAAC;QAEFsG,iBAAiB,CAAC;UAChBvG,cAAc;UACdyG,QAAQ;UACRC;QACF,CAAC,CAAC;MACJ;MAEA,IAAI1G,cAAc,EAAE,CAACmJ,OAAO,KAAK,OAAO,IAAInJ,cAAc,EAAE,CAACoJ,IAAI,KAAKpJ,cAAc,EAAE,CAACoJ,IAAI,CAACC,gBAAgB,CAAC,OAAO,CAAC,CAAC1G,MAAM,KAAK,CAAC,IAAI3C,cAAc,EAAE,CAACoJ,IAAI,CAACE,aAAa,CAAC,sBAAsB,CAAC,IAAItJ,cAAc,EAAE,CAACoJ,IAAI,CAACE,aAAa,CAAC,uBAAuB,CAAC,CAAC,EAAE;QAClQnK,IAAI,CAACiB,SAAS,CAACmJ,MAAM,CAACvJ,cAAc,EAAE,CAACoJ,IAAI,CAAC;MAC9C;IACF;EACF;EAEAjK,IAAI,CAACiB,SAAS,CAACG,KAAK,CAACP,cAAc,EAAE,EAAE;IACrCL,GAAG;IACHC,OAAO;IACPU,KAAK,EAAEV,OAAO;IACd,GAAGK;EACL,CAAC,CAAC;AACJ;AAEA,SAAS2B,SAASA,CAAA4H,MAAA,EAGf;EAAA,IAHgB;IACjBxJ,cAAc;IACdC;EACF,CAAC,GAAAuJ,MAAA;EACC,MAAM7J,GAAG,GAAG,QAAQ;EACpB,MAAMC,OAAO,GAAG,EAAE;EAElBT,IAAI,CAACiB,SAAS,CAACC,OAAO,CAACL,cAAc,EAAE,EAAE;IACvCL,GAAG;IACHC,OAAO;IACPU,KAAK,EAAEV,OAAO;IACd,GAAGK;EACL,CAAC,CAAC,CAAC,CAAC;;EAGJd,IAAI,CAACiB,SAAS,CAACG,KAAK,CAACP,cAAc,EAAE,EAAE;IACrCL,GAAG;IACHC,OAAO;IACPU,KAAK,EAAEV,OAAO;IACd,GAAGK;EACL,CAAC,CAAC;AACJ;AAEA,SAAS4B,SAASA,CAAA4H,MAAA,EAGf;EAAA,IAHgB;IACjBzJ,cAAc;IACdC;EACF,CAAC,GAAAwJ,MAAA;EACC,MAAM9J,GAAG,GAAG,QAAQ;EACpB,MAAMC,OAAO,GAAG,EAAE;EAElB,MAAM6H,2BAA2B,GAAGtI,IAAI,CAACiB,SAAS,CAACC,OAAO,CAACL,cAAc,EAAE,EAAE;IAC3EL,GAAG;IACHC,OAAO;IACPU,KAAK,EAAEV,OAAO;IACd,GAAGK;EACL,CAAC,CAAC;EAEF,IAAIwH,2BAA2B,EAAE;IAC/Bd,sBAAsB,CAAC;MAAE,GAAG8B,uBAAuB,CAACzI,cAAc,EAAE,CAAC;MACnEC,cAAc,EAAE;QACdmI,SAAS,EAAE,sBAAsB;QACjC,GAAGnI;MACL,CAAC;MACDD;IACF,CAAC,CAAC;EACJ;EAEAb,IAAI,CAACiB,SAAS,CAACG,KAAK,CAACP,cAAc,EAAE,EAAE;IACrCL,GAAG;IACHC,OAAO;IACPU,KAAK,EAAEV,OAAO;IACd,GAAGK;EACL,CAAC,CAAC;AACJ;AAEA,SAAS6B,eAAeA,CAAA4H,MAAA,EAGrB;EAAA,IAHsB;IACvB1J,cAAc;IACdC;EACF,CAAC,GAAAyJ,MAAA;EACC,MAAM/J,GAAG,GAAG,WAAW;EACvB,MAAMC,OAAO,GAAG,CAAC;EAEjB,MAAM6H,2BAA2B,GAAGtI,IAAI,CAACiB,SAAS,CAACC,OAAO,CAACL,cAAc,EAAE,EAAE;IAC3EL,GAAG;IACHC,OAAO;IACPU,KAAK,EAAEV,OAAO;IACd,GAAGK;EACL,CAAC,CAAC;EAEF,IAAIwH,2BAA2B,EAAE;IAC/Bd,sBAAsB,CAAC;MAAE,GAAG4B,0BAA0B,CAACvI,cAAc,EAAE,CAAC;MACtEC,cAAc,EAAE;QACdmI,SAAS,EAAE,uBAAuB;QAClC,GAAGnI;MACL,CAAC;MACDD;IACF,CAAC,CAAC;EACJ;EAEAb,IAAI,CAACiB,SAAS,CAACG,KAAK,CAACP,cAAc,EAAE,EAAE;IACrCL,GAAG;IACHC,OAAO;IACPU,KAAK,EAAEV,OAAO;IACd,GAAGK;EACL,CAAC,CAAC;AACJ;AAEA,SAAS8B,eAAeA,CAAA4H,MAAA,EAErB;EAAA,IAFsB;IACvB3J;EACF,CAAC,GAAA2J,MAAA;EACC3J,cAAc,EAAE,CAACuG,iBAAiB,CAAC,CAAC,EAAE,CAAC,CAAC,EAAElH,MAAM,CAAC8E,QAAQ,EAAEnE,cAAc,EAAE,CAAC,CAAC2C,MAAM,CAAC;AACtF;AAEA,SAASX,WAAWA,CAACqE,OAAO,EAAE;EAC5B,IAAI,CAAC,CAAC,EAAEhH,MAAM,CAACyH,gBAAgB,EAAET,OAAO,CAACrG,cAAc,EAAE,CAAC,EAAE;IAC1D4J,sBAAsB,CAACvD,OAAO,CAAC;IAC/B;EACF;EAEAC,aAAa,CAAC,GAAG,EAAED,OAAO,CAAC;AAC7B;AAEA,SAASuD,sBAAsBA,CAAAC,MAAA,EAG5B;EAAA,IAH6B;IAC9B7J,cAAc;IACdC;EACF,CAAC,GAAA4J,MAAA;EACC,MAAMlK,GAAG,GAAG,GAAG;EACf,MAAMC,OAAO,GAAG,EAAE;EAElB,MAAM4H,0BAA0B,GAAGrI,IAAI,CAACiB,SAAS,CAACC,OAAO,CAACL,cAAc,EAAE,EAAE;IAC1EL,GAAG;IACHC,OAAO;IACPU,KAAK,EAAEV,OAAO;IACd,GAAGK;EACL,CAAC,CAAC;EAEF,IAAIuH,0BAA0B,EAAE;IAC9BrI,IAAI,CAACiB,SAAS,CAACsH,QAAQ,CAAC1H,cAAc,EAAE,EAAE;MACxCL,GAAG;MACHC,OAAO;MACP+H,QAAQ,EAAE/H,OAAO;MACjB,GAAGK;IACL,CAAC,CAAC;EACJ;EAEA,MAAM6J,wBAAwB,GAAG3K,IAAI,CAACiB,SAAS,CAACG,KAAK,CAACP,cAAc,EAAE,EAAE;IACtEL,GAAG;IACHC,OAAO;IACPU,KAAK,EAAEV,OAAO;IACd,GAAGK;EACL,CAAC,CAAC;EAEF,IAAIuH,0BAA0B,IAAIsC,wBAAwB,EAAE;IAC1D3K,IAAI,CAACiB,SAAS,CAACmD,KAAK,CAACvD,cAAc,EAAE,EAAE;MAAE,GAAGC;IAC5C,CAAC,CAAC;EACJ;AACF;AAEA,SAASwB,eAAeA,CAAAsI,MAAA,EAGrB;EAAA,IAHsB;IACvB/J,cAAc;IACdC;EACF,CAAC,GAAA8J,MAAA;EACC,MAAMpK,GAAG,GAAG,WAAW;EACvB,MAAMC,OAAO,GAAG,EAAE;EAElBT,IAAI,CAACiB,SAAS,CAACC,OAAO,CAACL,cAAc,EAAE,EAAE;IACvCL,GAAG;IACHC,OAAO;IACPU,KAAK,EAAEV,OAAO;IACd,GAAGK;EACL,CAAC,CAAC;EAEFd,IAAI,CAACiB,SAAS,CAACG,KAAK,CAACP,cAAc,EAAE,EAAE;IACrCL,GAAG;IACHC,OAAO;IACPU,KAAK,EAAEV,OAAO;IACd,GAAGK;EACL,CAAC,CAAC;AACJ;AAEA,SAASyB,aAAaA,CAAAsI,MAAA,EAGnB;EAAA,IAHoB;IACrBhK,cAAc;IACdC;EACF,CAAC,GAAA+J,MAAA;EACC,MAAMrK,GAAG,GAAG,SAAS;EACrB,MAAMC,OAAO,GAAG,EAAE;EAElBT,IAAI,CAACiB,SAAS,CAACC,OAAO,CAACL,cAAc,EAAE,EAAE;IACvCL,GAAG;IACHC,OAAO;IACPU,KAAK,EAAEV,OAAO;IACd,GAAGK;EACL,CAAC,CAAC;EAEFd,IAAI,CAACiB,SAAS,CAACG,KAAK,CAACP,cAAc,EAAE,EAAE;IACrCL,GAAG;IACHC,OAAO;IACPU,KAAK,EAAEV,OAAO;IACd,GAAGK;EACL,CAAC,CAAC;AACJ"},"metadata":{},"sourceType":"script","externalDependencies":[]}